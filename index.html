<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sheikh Zada — JWT Generator</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--muted:#94a3b8;--accent:#6ee7b7;--accent2:#60a5fa}
    body{margin:0;font-family:Inter,ui-sans-serif;background:#071027;color:#e6eef8;display:flex;justify-content:center;padding:20px}
    .app{max-width:1000px;width:100%;background:#0b1220;border-radius:12px;padding:20px;box-shadow:0 8px 30px rgba(0,0,0,0.5)}
    header{display:flex;align-items:center;gap:14px;margin-bottom:12px}
    .logo{width:62px;height:62px;border-radius:10px;background:linear-gradient(135deg,var(--accent),var(--accent2));display:flex;align-items:center;justify-content:center;font-weight:700;color:#032}
    h1{font-size:20px;margin:0}
    .card{background:rgba(255,255,255,0.02);padding:14px;border-radius:10px;margin-top:12px}
    input[type=text], textarea{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;font-size:13px}
    textarea{min-height:100px;resize:vertical}
    .btn{padding:8px 12px;border:none;border-radius:8px;cursor:pointer;background:linear-gradient(90deg,var(--accent),var(--accent2));color:#042;font-weight:600;margin:4px 0}
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.1);color:var(--accent)}
    .btn:disabled{opacity:0.6;cursor:not-allowed}
    table{width:100%;border-collapse:collapse;margin-top:10px;font-size:13px}
    th,td{padding:6px 8px;border-bottom:1px solid rgba(255,255,255,0.05);word-break:break-all;text-align:left}
    .status-success{color:#9ae6b4}
    .status-error{color:#f87171}
    footer{text-align:center;margin-top:14px;color:var(--muted);font-size:12px}
    .summary{margin:10px 0;font-size:14px}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="logo">SZ</div>
      <div>
        <h1>Sheikh Zada — JWT Generator</h1>
      </div>
    </header>

    <div class="card">
      <h3>Input</h3>
      <input id="fileInput" type="file" accept="application/json,text/plain" class="btn ghost">
      <textarea id="pasteArea" placeholder='Paste JSON or uid,password lines here'></textarea>
      <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
        <button id="startBtn" class="btn">Generate</button>
        <button id="retryBtn" class="btn ghost" style="display:none">Retry Dead</button>
      </div>
      <div class="summary">
        Total: <span id="total">0</span> | 
        ✅ Live: <span id="liveCount">0</span> | 
        ❌ Dead: <span id="deadCount">0</span>
      </div>
    </div>

    <div class="card">
      <h3>✅ Live UIDs</h3>
      <div id="liveWrap"><div>No Live UID yet</div></div>
      <div style="margin-top:8px">
        <button id="downloadLiveCSV" class="btn ghost" style="display:none">Download Live CSV</button>
        <button id="downloadLiveJSON" class="btn ghost" style="display:none">Download Live JSON</button>
      </div>
    </div>

    <div class="card">
      <h3>❌ Dead UIDs</h3>
      <div id="deadWrap"><div>No Dead UID yet</div></div>
    </div>

    <footer>Sheikh Zada</footer>
  </div>

<script>
function safeParseJSON(text) {
  try { return JSON.parse(text); } catch { return null; }
}
function timeout(ms){ return new Promise(r => setTimeout(r, ms)); }
function fetchWithTimeout(input, ms = 6000) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), ms);
  return fetch(input, { signal: controller.signal })
    .finally(() => clearTimeout(id));
}
function shuffle(arr) {
  return arr.map(v => [Math.random(), v]).sort((a,b)=>a[0]-b[0]).map(v=>v[1]);
}

async function parseInput() {
  const txt = document.getElementById("pasteArea").value.trim();
  let parsed = [];
  if (txt) {
    try {
      if (txt.startsWith("[")) parsed = JSON.parse(txt);
      else if (txt.startsWith("{")) parsed = [JSON.parse(txt)];
      else parsed = txt.split(/\n+/).map(line => {
        const parts = line.split(/,|\s+/).filter(Boolean);
        return { uid: parts[0] || "", password: parts[1] || "" };
      });
    } catch {
      alert("Invalid pasted data");
      return [];
    }
  }
  return parsed;
}

document.getElementById("fileInput").addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const text = await file.text();
  document.getElementById("pasteArea").value = text;
});

const PROXIES = [
  "https://api.allorigins.win/raw?url=",
  "https://thingproxy.freeboard.io/fetch/",
  "https://corsproxy.io/?",
  "https://allorigins.hexlet.app/raw?url=",
  "https://cors.bridged.cc/",
  "https://yacdn.org/proxy/",
  "https://cors.isomorphic.site/",
  "https://corsproxy.github.io/?",
  "https://api.codetabs.com/v1/proxy?quest=",
  "https://proxy.cors.sh/",
  "https://cors.fluxo.info/",
  "https://cors.iamnd.eu/",
  "https://crossorigin.zimjs.com/api?url=",
  "https://open.cors.workers.dev/?",
  "https://fetch.sirv.com/?url=",
  "https://get.corsproxy.io/?",
  "https://proxy-thing.glitch.me/?url=",
  "https://service.cors.sh/",
  "https://proxyapi.glitch.me/?url=",
  "https://anyorigin.vercel.app/api?url=",
  "https://justcors.com/l_request?url="
];

const CONCURRENCY = 12;
const UID_ATTEMPTS = 3;
const RETRY_ATTEMPTS = 5;
const PROXY_TIMEOUT = 5000;

let liveRows = [];
let deadRows = [];

function updateCounters() {
  document.getElementById("liveCount").textContent = liveRows.length;
  document.getElementById("deadCount").textContent = deadRows.length;
  document.getElementById("retryBtn").style.display = deadRows.length ? "inline-block" : "none";
}

function renderTables() {
  const liveWrap = document.getElementById("liveWrap");
  const deadWrap = document.getElementById("deadWrap");

  if (liveRows.length) {
    liveWrap.innerHTML = `<table><thead><tr><th>UID</th><th>Token</th></tr></thead>
      <tbody>${liveRows.map(r => `<tr><td>${r.uid}</td><td>${r.token}</td></tr>`).join("")}</tbody></table>`;
    document.getElementById("downloadLiveCSV").style.display = "inline-block";
    document.getElementById("downloadLiveJSON").style.display = "inline-block";
  } else {
    liveWrap.innerHTML = "<div>No Live UID yet</div>";
    document.getElementById("downloadLiveCSV").style.display = "none";
    document.getElementById("downloadLiveJSON").style.display = "none";
  }

  if (deadRows.length) {
    deadWrap.innerHTML = `<table><thead><tr><th>UID</th><th>Error</th></tr></thead>
      <tbody>${deadRows.map(r => `<tr><td>${r.uid}</td><td>${r.error||""}</td></tr>`).join("")}</tbody></table>`;
  } else {
    deadWrap.innerHTML = "<div>No Dead UID yet</div>";
  }
}

async function tryProxiesForUidOnce(uid, password, useShuffle=false) {
  const urlPath = `https://jnl-gen-jwt.vercel.app/token?uid=${encodeURIComponent(uid)}&password=${encodeURIComponent(password || "")}`;
  const proxyList = useShuffle ? shuffle(PROXIES) : PROXIES;

  for (const proxy of proxyList) {
    try {
      const res = await fetchWithTimeout(proxy + encodeURIComponent(urlPath), PROXY_TIMEOUT);
      let text = await res.text();
      if (!text) continue;
      if (text.includes("What's up?") || text.toLowerCase().includes("<!doctype")) continue;
      let j = safeParseJSON(text);
      if (!j && text) j = { token: text };
      const token = j && (j.token || j.jwt || j.access_token);
      if (token && typeof token === "string" && token.startsWith("eyJ")) return token;
    } catch {}
  }
  return null;
}

async function resolveTokenWithRetries(uid, password, attempts = UID_ATTEMPTS, shuffleProxies=false) {
  for (let i = 0; i < attempts; i++) {
    const token = await tryProxiesForUidOnce(uid, password, shuffleProxies);
    if (token) return token;
    await timeout(150 * (i+1));
  }
  return null;
}

async function processAll(data, isRetry=false) {
  const queue = data.slice();
  const workers = Array.from({length: CONCURRENCY}, async () => {
    while (true) {
      const item = queue.shift();
      if (!item) break;
      const uid = item.uid?.toString().trim();
      const password = item.password || "";
      if (!uid) continue;
      if (liveRows.some(r => r.uid === uid)) continue;
      const token = await resolveTokenWithRetries(uid, password, isRetry ? RETRY_ATTEMPTS : UID_ATTEMPTS, isRetry);
      if (token) {
        if (!liveRows.some(r => r.uid === uid)) {
          liveRows.push({ uid, token });
          deadRows = deadRows.filter(d => d.uid !== uid);
        }
      } else {
        if (!deadRows.some(d => d.uid === uid) && !liveRows.some(r => r.uid === uid)) {
          deadRows.push({ uid, error: "No token / proxy failed" });
        }
      }
      updateCounters();
      renderTables();
      await timeout(20);
    }
  });
  await Promise.all(workers);
}

async function startProcessing() {
  const startBtn = document.getElementById("startBtn");
  startBtn.disabled = true;
  startBtn.textContent = "Generating...";
  const data = await parseInput();
  if (!data.length) {
    alert("No input data");
    startBtn.disabled = false;
    startBtn.textContent = "Generate";
    return;
  }
  liveRows = [];
  deadRows = [];
  document.getElementById("total").textContent = data.length;
  updateCounters();
  renderTables();
  await processAll(data);
  startBtn.disabled = false;
  startBtn.textContent = "Generate";
  alert("Processing finished — Live: " + liveRows.length + "  Dead: " + deadRows.length);
}

async function retryDead() {
  if (!deadRows.length) return;
  const retryData = deadRows.map(d => ({uid:d.uid, password:""}));
  deadRows = [];
  updateCounters();
  renderTables();
  await processAll(retryData, true);
}

document.getElementById("startBtn").addEventListener("click", startProcessing);
document.getElementById("retryBtn").addEventListener("click", retryDead);

document.getElementById("downloadLiveCSV").onclick = () => {
  const csv = ["UID,Token"].concat(liveRows.map(r => `${r.uid},"${r.token.replace(/"/g,'""')}"`)).join("\n");
  const blob = new Blob([csv], { type: "text/csv" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "live_tokens.csv";
  a.click();
};
document.getElementById("downloadLiveJSON").onclick = () => {
  const blob = new Blob([JSON.stringify(liveRows, null, 2)], { type: "application/json" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "live_tokens.json";
  a.click();
};

renderTables();
updateCounters();
</script>
</body>
</html>
